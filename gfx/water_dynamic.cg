struct VIn
{
    float4 p : POSITION;
    float4 n : NORMAL;
    float3 t : TANGENT;
    float2 uv  : TEXCOORD0;
    float3 c : COLOR;
};

struct VOut
{
    float4 p : POSITION;
    float4 uv  : TEXCOORD0;
    float4 wp  : TEXCOORD1;
    float3 n : TEXCOORD2;
    float3 t : TEXCOORD3;
    float4 vVec : TEXCOORD5;
    float3 b : TEXCOORD6;
	float3 waveNormal : TEXCOORD7;
};

struct PIn
{
    float4 uv  : TEXCOORD0;
    float4 wp  : TEXCOORD1;
    float4 n : TEXCOORD2;
    float4 t : TEXCOORD3;
    float4 vVec : TEXCOORD5;
    float3 b : TEXCOORD6;
	float3 waveNormal : TEXCOORD7;
};

float4 waveFunc(float2 waveSizeSpeed, float time, float hole, sampler2D dispMap, float2 inUv)
{
	float waveScale = 4;
	float waveScale2 = 7;
    float waveSize = waveSizeSpeed.x*10;
	float waveSpeed = waveSizeSpeed.y/15;
	
	float2 uv = inUv/waveScale;
	uv.y += time*waveSpeed/4.5;
	uv.x*=2;
	float4 wMapSmall = tex2D(dispMap, uv);

	uv = inUv/waveScale2;
	uv.y += time*waveSpeed/2.0;
	uv.x*=1;
	float4 wMapBig = tex2D(dispMap, uv);
	
	float splashDist = 10;
	float splashPower = 10;
	float waveW = hole;
	
	float add = (wMapSmall.r+wMapBig.r*2)*waveSize;
	add -= waveW*splashPower;
	
	return float4(uv, add, wMapSmall.x + wMapBig.x);
}

VOut wdiffuse_vs_op(VIn IN,
	uniform float4x4 wMat,
	uniform float4x4 vpMat,
	uniform float3 camPos,
	uniform float time,
	uniform float3 waveSeedSizeSpeed,
	uniform sampler2D dispMap : register(s0),
	uniform sampler2D normMap : register(s1)
)
{
    VOut OUT;
    float4 wpos = mul(wMat, IN.p);
	float4 wnor = mul(wMat, IN.n);
	
	//xy = wave map uv, z = add height, w = direct height map 
	float4 waveParams = waveFunc(waveSeedSizeSpeed.yz, time, IN.c.r, dispMap, IN.uv.xy); 

	wpos.y += waveParams.z;
	float3 wMapNormal = tex2D(normMap, waveParams.xy).rgb;
	
	float foamDirect = saturate(3*IN.c.g + IN.c.b*2);
	float waveW = IN.c.r;
	foamDirect += waveW;
	
	OUT.p = mul(vpMat, wpos);

	OUT.wp.xyz=wpos.xyz;
    
    OUT.uv.xy = IN.uv.xy;
    OUT.uv.zw=OUT.p.zw;
    
	OUT.waveNormal = wMapNormal;
	
	wMapNormal = 0.001*wMapNormal + IN.n.rgb;

    OUT.n.xyz = wMapNormal;
    OUT.t.xyz = IN.t;
    OUT.b.xyz = cross(IN.t.xyz, wMapNormal);
     
    float3 viewVec = camPos - IN.p.xyz;
    OUT.vVec.x = dot(viewVec, OUT.t );
    OUT.vVec.y = dot(viewVec, OUT.b );
    OUT.vVec.z = dot(viewVec, wMapNormal );
    
	float3 eyeDir = normalize(IN.p.xyz - camPos.xyz);
	OUT.vVec.w = pow(1+dot(eyeDir, wMapNormal), 1.5);
	
	OUT.wp.w = max(waveParams.w/4,foamDirect);//OUT.vVec.w*add*IN.c.r/(waveSize*1.5);
	
    return OUT;
}

float3 color_blend(float3 normalTex, float3 normalTex2)
{
	float3 r;
	r = (normalTex < 0.5 ? (2.0 * normalTex * normalTex2) : (1.0 - 2.0 * (1.0 - normalTex) * (1.0 - normalTex2)));
	return r;
}

void wdiffuse_ps_op(
	PIn IN,
	uniform float scrollTime,
	uniform float speed,
	uniform float2 scaleDiff,
	uniform float4 lightPos0,
	uniform float3 camPos,
	uniform float playerSpeed,
	uniform float4 fogColor,
	uniform float4 fogParams,
	uniform float4x4 iTWMat,
	uniform sampler2D diffuseMap : register(s2),
	uniform sampler2D normalMap : register(s3),
	uniform sampler2D foamMap : register(s4),
	uniform sampler2D reflMap : register(s5),
	uniform sampler2D depthMap : register(s6),
	float2 screenSpace : WPOS,
	out float4 color0 : COLOR0,
	out float4 color1 : COLOR1,
	out float4 color2 : COLOR2,
	out float4 color3 : COLOR3
)
{
    float foamScale = 5;
	float normalScale = 3;
	float normalSpeed = 2.5;
	float2 texCoord = IN.uv.xy;
    float speedUV=speed*0.2;
    float foamTerm=IN.wp.w;//*0.75+0.25;
	
    // direction
    float3 ld0 = normalize(lightPos0.xyz - (lightPos0.w * IN.wp.xyz));
    //ld0.xz = lerp(ld0.xz,-ld0.xz,foamTerm);  
    
    texCoord.y += scrollTime * speedUV*normalSpeed;
    
	float3 normalTex = tex2D(normalMap, texCoord*scaleDiff*normalScale*5).rgb;
	
	texCoord.y += scrollTime * speedUV * 0.5;
	
    normalTex += tex2D(normalMap, texCoord*scaleDiff*normalScale).rgb;
    
	normalTex /= 2;
	
    texCoord += float2(0.5,scrollTime * speedUV*normalSpeed);
    float height = normalTex.z;
    normalTex.z=1;
    
    normalTex = color_blend(normalTex,IN.waveNormal);
    
    // Parallax mapping
    //float height = tex2D(dispMap, texCoord.xy*scaleDiff).x;
    texCoord = IN.uv.xy + saturate(speed)*(0.015 * height - 0.05) * normalize(IN.vVec.xyz).xy;
    
	float2 diffUV = texCoord;
    diffUV.y += scrollTime * speedUV * 3;
	
	float4 diffTex = tex2D(diffuseMap, diffUV*scaleDiff/3);
	
    float3x3 tbn = float3x3(IN.t.xyz,IN.b.xyz, IN.n.xyz);
    float3 normal = mul(transpose(tbn), normalTex.xyz * 2 - 1); // to object space
    normal = normalize(mul((float3x3)iTWMat, normal));
    
    float3 diffuse = dot(ld0, normal)*0.5 + 0.5;//max(, foamTerm);
    
    texCoord.y += scrollTime * speedUV;
    
    float3 foamTex = tex2D(foamMap, texCoord*scaleDiff*foamScale/2).rgb*foamTerm;
	texCoord.y += scrollTime * speedUV * 0.5;
    texCoord.x += 0.25;
	
    foamTex += tex2D(foamMap, texCoord*scaleDiff*foamScale).rgb*foamTerm;
	foamTex/=2;
	
	float3 camDir = camPos - IN.wp.xyz;
	float dist = length(camDir);
	camDir = normalize(camDir);
	
	float3 Ru = normalize(-camDir);
	float3 Rn = normalize(normal.xyz);
	float3 Rr = reflect( Ru, Rn );
	float m = 2.0 * sqrt( Rr.x*Rr.x + Rr.y*Rr.y + (Rr.z+1.0)*(Rr.z+1.0) );

	float2 reflUV = float2(Rr.x/m + 0.5, Rr.y/m + 0.5);
	float3 reflectionTex = tex2D(reflMap,reflUV).rgb;
	
	float fresnel = pow(1 - abs(dot(camDir, normal)), 3);
	
    float3 diffuseContrib = reflectionTex*2;
    
    float3 light0C = (diffuseContrib) + foamTex;
    
   //float3 def=lerp(diffTex.rgb,foamTex.rgb,foamTerm)*2;
    float3 def=lerp(diffTex.rgb,foamTex.rgb,foamTerm)*diffuse;
	
	float2 depthTexCoord=screenSpace/float2(1280.0f,768.0f);
	float3 depthEnv=tex2D(depthMap,depthTexCoord).rgb;  
	float depth = saturate((depthEnv.g - IN.uv.z)/5);
	float alpha = (diffTex.a*0.75*depth + foamTerm*foamTex.r + fresnel);
	
    color0=float4(def*light0C*alpha,alpha);
	
	//distance fog
	float insideFog = saturate((dist - fogParams.y) / fogParams.z)*fogColor.a;
	float3 atmFog = fogColor.rgb;
	color0.rgb = lerp(color0.rgb, atmFog, insideFog);
	
	//float2(0.5,0.5);
    float2 normalOut = IN.waveNormal.xy;//*clamp((15-IN.uv.z)/15,0.5,1);//normalTex.rg;//lerp(float2(0.5,0.5),normalTex.rg,saturate(speed)*);
	
	float shine = reflectionTex.r*fresnel*0.5;
    color1=float4(normalOut,0.2 ,1);
    color2=pow(color0*3,5);
    color3=float4(IN.uv.z/IN.uv.w,IN.uv.z,0,0);
}

struct VOutLite
{
    float4 p : POSITION;
    float4 wp  : TEXCOORD0;
};

struct PInLite
{
    float4 wp  : TEXCOORD0;
};

VOutLite wdiffuseLite_vs_op(VIn IN,
	uniform float4x4 wMat,
	uniform float4x4 vpMat,
	uniform float time,
	uniform float3 waveSeedSizeSpeed,
	uniform sampler2D dispMap : register(s0)
)
{
    VOutLite OUT;
    float4 wpos = mul(wMat, IN.p);
	
	//xy = wave map uv, z = add height, w = direct height map 
	float4 waveParams = waveFunc(waveSeedSizeSpeed.yz, time, IN.c.r, dispMap, IN.uv.xy); 

	wpos.y += waveParams.z;
	
	OUT.p = mul(vpMat, wpos);
	OUT.wp.xyz=wpos.xyz;
    
    return OUT;
}

void wDepth_ps_op(
	PInLite IN,
	out float4 color : COLOR
)
{
    color.rgb = IN.wp.yxz;
}

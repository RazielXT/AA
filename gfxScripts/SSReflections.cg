float4 TraceSSReflections_fp
    (
         float2 uv: TEXCOORD0,
		 uniform float4x4 invProjMatrix,
		 uniform float4x4 projMatrix,
         uniform sampler2D map: register(s0),
		 uniform sampler2D mapSS: register(s1),
		 uniform sampler2D mapDepth: register(s2)
    ) : COLOR
{   
	float4 scene = tex2D(map, uv);
	
	float3 viewNormal = tex2D(mapSS, uv).xyz;
	
	if(viewNormal.x+viewNormal.y+viewNormal.z == 0)
		return 0;
	
	viewNormal = normalize(viewNormal);
	
	//viewNormal = viewNormal*2 - 1;
		
	float zOverW = 1 - tex2D(mapDepth, uv).r;
	float4 H = float4(uv.x * 2 - 1, (1 - uv.y) * 2 - 1, zOverW, 1);  
	
	float4 cameraVP = mul(invProjMatrix, H);
	cameraVP.xyz = cameraVP.xyz / cameraVP.w;	
	cameraVP.xyz *= 0.5;
	
	float3 camDir = normalize(cameraVP.xyz);
	
	//return cameraVP;
	//cameraVP.z *= -1;

	float3 rayDirVP = normalize(reflect(camDir, viewNormal));
	//rayDirVP.z *= 0.5;
	//rayDirVP.xyz *= 1 + pow(abs(rayDirVP.z)*2,2);
	float steepW = pow(saturate(dot(rayDirVP,camDir)),2);
	
	float distCorrect = steepW*6;
	rayDirVP.xyz *= 1 + distCorrect;

	//cameraVP.xz *= -1;
	
	//return float4(rayDirVP,1);
	
	float stepSize = 1 + saturate(-cameraVP.z/50)*2;
	float steps = 20.0;
	//float2 size = 1/float2(1280,768);
	
	//rayDirVP = rayDirVP*stepSize;
	float3 startPos = cameraVP.xyz;
	
	float3 offset = rayDirVP*stepSize*steps;
	float3 endPos = cameraVP.xyz + offset;
	endPos.z = min(endPos.z,0);

	//return float4(rayDirVP.xyzx);
	//return float4(endPosSS.xy,startPosSS.xy);

	float3 vpStep = (endPos.xyz - startPos.xyz)/(steps);
	float3 curPosVP = startPos.xyz;

	
	float4 reflScene = scene;
	float3 sampledUV = 1.0;
	float3 sampledPosVP = 0;
	float sampledDepth = 0;
	float sampledStep = 0;
	float vpNormalDot = 0;
	
	float sampledDif = 0;
	float sampledDifMax = 10.0 + steepW*10;
	
	
	for(int i=0; i<steps; i++)
	{
		curPosVP += vpStep;
		float checkDepth = -curPosVP.z;
		
		float4 curPosSS = mul(projMatrix, float4(curPosVP,1));
		curPosSS.xy =  ((curPosSS.xy/curPosSS.w))*0.5 + 0.5; 
		curPosSS.y = 1 - curPosSS.y;
		
		float4 curUV = float4(curPosSS.xy,1,1);
				
		float depth = tex2Dlod(mapDepth, curUV).g;
		float4 reflSceneSample = tex2Dlod(map, curUV);
		float3 sampleVPNormal = tex2Dlod(mapSS, curUV).xyz;
		
		float sampledNormalDot =  dot(sampleVPNormal,normalize(vpStep));
		
		sampledDif = checkDepth - depth;
		
		//if(checkDepth > depth && ((checkDepth - depth) > 0))
		if(sampledDif > 0 && sampledDif < sampledDifMax)
		{
			vpNormalDot = sampledNormalDot;
			reflScene = reflSceneSample;
			sampledUV = curPosSS.xyz;
			sampledPosVP = curPosVP;
			sampledDepth = depth;
			sampledStep = i;	
			
			break;
		}
	}
	
	float detailSteps = 2.0;
	float detailStepSize = stepSize/detailSteps;
	float3 vpMinStep = vpStep/detailSteps;
	float sampledSubStep = 0;
	
	if(sampledStep>0)
	for(int i=0; i<detailSteps; i++)
	{
		curPosVP -= vpMinStep;
		float checkDepth = -curPosVP.z;
		
		float4 curPosSS = mul(projMatrix, float4(curPosVP,1));
		curPosSS.xy =  ((curPosSS.xy/curPosSS.w))*0.5 + 0.5; 
		curPosSS.y = 1 - curPosSS.y;
		
		float4 curUV = float4(curPosSS.xy,1,1);
				
		float depth = tex2Dlod(mapDepth, curUV).g;
		float4 reflSceneSample = tex2Dlod(map, curUV);
		float3 sampleVPNormal = tex2Dlod(mapSS, curUV).xyz;
		
		float sampledNormalDot =  dot(sampleVPNormal,normalize(vpStep));
		
		float sampledDDif = checkDepth - depth;
		
		//if(checkDepth > depth && ((checkDepth - depth) > 0))
		if(sampledDDif > 0 && sampledDDif < sampledDifMax)
		{
			sampledDif = sampledDDif;
			vpNormalDot = sampledNormalDot;
			reflScene = reflSceneSample;
			//sampledUV = curPosSS.xyz;
			sampledPosVP = curPosVP;
			sampledDepth = depth;
			sampledSubStep = i;
				
			//i = steps;
		}
		else
			break;
	}
	
	float reflW = 1.0;
	
	if ( sampledUV.x>0.5 ) sampledUV.x = 1.0 - sampledUV.x ;
	if ( sampledUV.y>0.5 ) sampledUV.y = 1.0 - sampledUV.y ;
	
	reflW = reflW * clamp (sampledUV.x * 10.0 , 0.0 , 1.0 );
	reflW = reflW * clamp (sampledUV.y * 10.0 , 0.0 , 1.0 );
		
	float stepsW = steps + 1;
	stepsW = (stepsW-sampledStep)/stepsW;
	
	float stepsWD = 1.0 - (detailSteps-sampledSubStep)/detailSteps;
	stepsWD /= steps;
	
	//reflW *= pow(1.0 - sampledDif/sampledDifMax,1);
	
	reflW *= stepsW+stepsWD;
	
	reflW *= pow(saturate(sampledPosVP.z/-10),2);
	
	//reflW  *= saturate(1 - pow(sampledDif/10,1)); //1.0/(1.0 + abs(sampledDepth - -sampledPosVP.z )*10);

	scene.rgb = lerp(scene, reflScene, reflW);
	//scene.rgb = scene.rgb*0.001 + abs(vpStep.y);
	scene.a = sampledDepth;
	
	//scene.rgb = startPosSS.xyz;
			
	//scene/=steps+1;
	
	//scene.rgb = float3(-startPos.z, -endPos.z, 0)/100;
	//scene.b = 0;
	//scene.rgb = mul(projMatrix, cameraVP).rgb;//*float3(size,0);
	
	return scene;
}



float4 MergeSSReflections_fp
    (
         float2 uv: TEXCOORD0,
         uniform sampler2D map: register(s0),
		 uniform sampler2D mapNormal: register(s1),
		 uniform sampler2D mapSS: register(s2)
    ) : COLOR
{   
	float4 scene = tex2D(map, uv);
	float4 norm = tex2D(mapNormal,uv);
	float4 refl = tex2D(mapSS,uv);
	
	float relfterm = saturate(length(norm.xyz));

	return lerp(scene,refl,relfterm);
}




#define MAX_STEPS 300
#define MAX_INTERSECT_DIST 0.04

float2 NormalizedDeviceCoordToScreenCoord(float2 ndc)
{
   float2 Dimensions = 1.0;
   
   float2 screenCoord;
   screenCoord.x = Dimensions.x * (ndc.x + 1.0f) / 2.0f;
   screenCoord.y = Dimensions.y * (1.0f - ((ndc.y + 1.0f) / 2.0f));
   return screenCoord;
}

float4 TraceSSReflections2_fp
    (
         float2 uv: TEXCOORD0,
		 uniform float4x4 invProjMatrix,
		 uniform float4x4 projMatrix,
         uniform sampler2D map: register(s0),
		 uniform sampler2D mapSS: register(s1),
		 uniform sampler2D mapDepth: register(s2)
    ) : COLOR
{   
	float4 scene = tex2D(map, uv);
	float3 viewNormal = tex2D(mapSS, uv).xyz;
	
	if(viewNormal.x+viewNormal.y+viewNormal.z == 0)
		return scene;
		
	float zOverW = 1 - tex2D(mapDepth, uv).r;
	float4 H = float4(uv.x * 2 - 1, (1 - uv.y) * 2 - 1, zOverW, 1);  
	
	float4 cameraVP = mul(invProjMatrix, H);
	cameraVP.xyz = cameraVP.xyz / cameraVP.w;	
	cameraVP.xyz *= 0.5;

	float4 reflColor = float4(0, 0, 0, 0);
	float t = 1;
	float reflectivity = 0;
	
	float4 rayDirVP = float4(normalize(reflect(normalize(cameraVP.xyz), viewNormal)),1);

	float4 v0 = float4(cameraVP.xyz,1);
	float4 v1 = v0 + rayDirVP*30;
	v1.w = 1;
	
	float4 p0 = mul(projMatrix, v0);
	float4 p1 = mul(projMatrix, v1);

	float k0 = 1.0f / p0.w;
	float k1 = 1.0f / p1.w;

	p0 *= k0; 
	p1 *= k1;

	p0.xy = NormalizedDeviceCoordToScreenCoord(p0.xy);
	p1.xy = NormalizedDeviceCoordToScreenCoord(p1.xy);
	
	v0 *= k0;
	v1 *= k1;

	float divisions = length(p1 - p0)*30;
	float3 dV = (v1 - v0) / divisions;
	float dK = (k1 - k0) / divisions;
	float2 traceDir = (p1 - p0) / divisions;
	float2 Dimensions = 1.0;
	float2 coord = uv;
	
	float maxSteps = min(MAX_STEPS, divisions);
	float curDepth = 0;
	
	{
	   while( t < maxSteps)
	   {
		  coord = uv + traceDir * t;
		  
		  if(coord.x >= Dimensions.x || coord.y >= Dimensions.y || coord.x < 0 || coord.y < 0) break;

		  curDepth = (v0 + dV * t).z;
		  curDepth /= k0 + dK * t; // Reverse the perspective divide back to view space
		  float storedDepth = tex2Dlod(mapDepth, float4(coord.xy,1,1)).g;
		  
		  if( curDepth > storedDepth && curDepth - storedDepth < MAX_INTERSECT_DIST)
		  {
			 reflectivity = 1;
			 reflColor = tex2Dlod(map, float4(coord.xy,1,1));
			 break;
		  }
		  
		  t++;
	   }
	}
   
	return reflectivity;//(1.0f - reflectivity) + reflColor * reflectivity;
}